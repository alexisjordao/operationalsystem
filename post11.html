<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Operational Systems Blog</title>
  <link rel="stylesheet" href="files/css.css">
  <link rel="stylesheet" href="files/style.css">
  </head>
<body>
  <div class="container">
    <header class="masthead">
  <h1 class="masthead-title--small">
    <a href="http://alexisjordao.github.io/operationalsystems/">Operational systems</a>
  </h1>
</header>
<div class="content post">
  <h1 class="post-title">Kernel Module (Linux)</h1>
  <div class="post-date">
    <time>28 May 2016</time>
  </div>

  <p>What exactly is a kernel module? Modules are pieces of code that can be loaded and unloaded into the kernel upon demand. They extend the functionality of the kernel without the need of rebooting the system. For example, one type of module is the device driver, which allows the kernel to access hardware connected to the system. You can see what modules are already loaded into the kernel by running <b>lsmod</b>.</p>

  <p>The Simplest Module</p>

    <img src="files/kernel1.png"/> <br/>



      <p>Kernel modules must have at least two functions: a "start" (initialization) function called <b>init_module()</b> which is called when the module is insmoded into the kernel, and an "end" (cleanup) function called <b>cleanup_module()</b> which is called just before it is rmmoded. Typically, <b>init_module()</b> either registers a handler for something with the kernel, or it replaces one of the kernel functions with its own code (usually code to do something and then call the original function). The <b>cleanup_module()</b> function is supposed to undo whatever init_module() did, so the module can be unloaded safely.</p>

       <h6>Introducing printk()</h6>

      <p>It is to be a logging mechanism for the kernel, and is used to log information or give warnings. Therefore, each <b>printk()</b> statement comes with a priority, which is the &lt;1&gt; and KERN_ALERT you see. There are 8 priorities and the kernel has macros for them, so you don't have to use cryptic numbers, and you can view them (and their meanings) in <b>linux/kernel.h</b>. If you don't specify a priority level, the default priority, <i>DEFAULT_MESSAGE_LOGLEVEL</i>, will be used.</p>
      <p>If the priority is less than int console_loglevel, the message is printed on your current terminal. If both syslogd and klogd are running, then the message will also get appended to <b>/var/log/messages</b>, whether it got printed to the console or not. We use a high priority, like <i>KERN_ALERT</i>, to make sure the printk() messages get printed to your console rather than just logged to your logfile. When you write real modules, you'll want to use priorities that are meaningful for the situation at hand.</p>

      	<h6>Compiling Kernel Modules</h6>

      <p>Kernel modules need to be compiled a bit differently from regular userspace apps. Former kernel versions required us to care much about these settings, which are usually stored in Makefiles. Although hierarchically organized, many redundant settings accumulated in sublevel Makefiles and made them large and rather difficult to maintain.</p>

      <p>So, let's look at a simple Makefile for compiling a module named <b>hello.c</b>:</p>


    <img src="files/kernel2.png"/> <br/>

    <p>Now you can compile the module by issuing the command <b>make</b>.</p>
    <p>Use <b>modinfo hello.ko</b> to see what kind of information it is.</p>
    <p>Now as root it is time to insert your freshly-compiled module it into the kernel with <b>insmod ./hello.ko</b></p>
    <p>All modules loaded into the kernel are listed in /proc/modules. When the novelty wears off, remove your module from the kernel by using rmmod hello. Take a look at /var/log/messages just to see that it got logged to your system logfile.</p>

    <h6>The Simplest Module (part 2)</h6>

    <p>As of Linux 2.4, you can rename the init and cleanup functions of your modules; they no longer have to be called init_module() and cleanup_module() respectively. This is done with the module_init() and module_exit() macros. These macros are defined in linux/init.h.</p>

    <img src="files/kernel3.png"/> <br/>

    <p>Adding makefile for both our modules is as simple as this:</p>

    <img src="files/kernel4.png"/> <br/>

    <p>Hello World (part 3): The __init and __exit Macros</p>

    <img src="files/kernel5.png"/> <br/>


    <p>References</p>
    <ul>
      <li>Salzman, P. Jay; Burian, Michael; Pomerantz, Ori. The Linux Kernel Module Programming Guide. <a href="http://www.tldp.org/LDP/lkmpg/2.6/html/lkmpg.html" target="_blank"> http://www.tldp.org/LDP/lkmpg/2.6/html/lkmpg.html. </a></li>
    </ul>

    </div>

      </div>

</body></html>
